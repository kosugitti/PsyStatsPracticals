# 多群の平均値差の検定
心理学実験においては，古典的に分散分析モデルが多用されてきた。平均値差を見ることで実験の効果，因果関係を明らかにできるように，巧妙に実験デザインが組み立てられる。その精緻さは理論的一貫性という意味である種の美しさを持ち，多くの研究者が魅了されてきた。

分散分析にのせることを目的にした実験計画であり，実験デザインの不自由さ(とにかく分散分析をしなければならない!)が批判的に論じられることもあるが，心理学が測定している対象が平均値差以上の精度で議論できる性質でないという反論もあるだろう。

今や分散分析を超えたより高度な統計モデルがあり，現在の研究においては分散分析はもはや過去のものにすぎないかもしれないが，以後のモデルも分散分析を基本としたその発展系であるので，改めて基本を押さえておくことも重要である。

## 分散分析の基礎

分散分析は「分散」の分析であるかのような名称であるが，平均値差を検定するためのものである。なsぜ分散を冠するかといえば，効果量のところで見たように，平均値差の判断には群内分散の情報が必要だからである。

多群の平均値の差，その散らばりを群間分散といい，群に含まれるデータの散らばりを群内分散とよぶ。分散分析は群内分散に対する群間分散の比が十分に大きいと考えられる場合，群間に統計的な有意差があると判断する。分散の比を表す確率分布はF分布と呼ばれる。F分布は群間・群内それぞれの自由度を母数にもつ。

また，実験計画はBetweenデザインとWithinデザインに区分される。t検定でみたような，対応のない独立した群を対象にしたデザインがBetween，群間に相関が想定される対応のある群を対象にしたデザインがWithinである。Withinデザインは同じ個体から複数回の反応を得る(ex. period 1-2-3...)ため，反復測定デザインRepeated measured designともよばれることがある。この場合，群内分散から個人内の分散すなわち個人差を取り出すことができるため，これが分離できないBetweenデザインよりも基本的にWithinデザインのほうが目的となる変動を捉えやすい。ただし，反復測定による個体への負担を考えると，毎回Withinデザインでいいというわけにもいかないところが難点である。

$$Between Design: \text{全変動} = \text{群間変動}+ \text{群内変動(誤差)}$$
$$Within Design:  \text{全変動} = \text{群間変動}+ \text{個人内変動} + \text{誤差}$$

分散分析は要因が複数ある場合も考えられるから，要因AがBetween，要因BがWithinといった場合は混合計画と呼ばれることがある。慣例的に，要因Factorとその要因に含まれる水準Levelを同時に表現し，$\text{間}2 \times \text{間}3$の分散分析(二要因の分散分析で，いずれもBetweenデザインであり，水準数がそれぞれ2と3)，といった言い方をすることがある。

## 分散分析のステップ

t検定において等分散性の仮定が成立するかどうかが事前に問題になったように，Betweenデザインにおいても分散の等質性は仮定されており，Leveneの検定などで事前に検証しておくべきである。またWithinデザインにおいては，データの組成に関わる分散共分散行列の非対角要素が全て等しいことが望ましいが，実践的にはそこまでの仮定が成立しているとは考えにくい。ただし分散分析としては，等分散性の仮定よりも，より緩やかな球面性の仮定が成立していればよいとされており，これを事前に検定することが一般的である。Welchの補正のように，球面性の仮定が成立していない場合は，自由度を補正することで検定の精度が維持される。

分散分析は多要因・多水準の平均値差の検定である。各水準ごとにt検定を繰り返せば良いのではないか，というアイデアは誰しも思いつくことであろうが，この方法は検定の目的である$\alpha$水準の制御ができなくなるという問題を含む。そこで多水準の場合は分散分析を行うことで，すべての要因・水準の母平均が同じであるという帰無仮説を検定し，効果の有無をまず明確にする。この帰無仮説が棄却されたらどこかに差があるわけだから，以後は慎重に$\alpha$水準を制御しつつ事後的な検定にすすむ。

水準間の差をみるための事後的な検定は，下位検定とも呼ばれる。その方法は多岐に渡り，ゴールドスタンダードは存在せず，往々にして分析者が利用しているソフトウェアが対応する手法が選択される。要因・水準が多くなると検証すべき組み合わせも多くなり，下位検定の手続きも非常に煩雑になる。統計ソフトウェアはそれこそ機械的に，幾重にも細かく分散分析表を分解して下位検定をつづけていってくれるが，いくら制御されているとはいえ検定を繰り返していることに変わりはないし，各下位検定の結果を一貫した総合的解釈をするのは困難である。実験計画はシンプルであるほうが望ましいし，複雑なモデルになるようであれば分散分析を超えた，階層線形モデルやベイジアンアプローチなどを取る方が良いだろう。

## ANOVA君を使う

分散分析をRで実行するには，基本関数である`aov`やcarパッケージなどを用いることができる。
もっとも，その出力は必ずしも親切ではないし，下位検定や効果量の算出などは別のパッケージ，別の関数を用いる必要がある。

筆者がお勧めするのは，大正大学の井関龍太が開発した[anovakun](https://riseki.cloudfree.jp/?ANOVA君)である。パッケージ化されていないので，リンク先からソースコードを読み込んでanovakun関数を実行する必要があるが，さまざまな実験デザインに対応し，また下位検定や効果量，球面性の補正などおよそ分散分析で必要な手法は網羅されている。以下ではこれを用いた実践を行う。

anovakunの読み込みは，ソースコードをプロジェクトフォルダにダウンロードして`source`関数で読み込むか，インターネットに繋がっている状態でリンク先から直接ソースファイル(anovakun_489.txt)[^9.1]を`source`関数で読み込むといいだろう。

```{r}
source("https://riseki.cloudfree.jp/?plugin=attach&refer=ANOVA%E5%90%9B&openfile=anovakun_489.txt")
```

[^9.1]: 2024.06.12時点での最新バージョンが4.8.9である。リンク先URLは，公式サイトからソースファイルのリンクをコピーして貼り付けると良い。

読み込みが終わるとEnvironタブにanovakun関数が含まれていることを確認しよう。

### ANOVA君の入力とデータ

ANOVA君は伝統的にワイド型データから読み込むようになっている。すなわち，一行に1オブザベーション入っている形式である。Between計画の場合は，データの前に水準数を表すインデックスと最終的な従属変数の形に整形したデータが必要である。Within計画の場合は1行に1Obs.なのだから，反復した水準の数だけ右にデータを入れていく形に整形する。

しかし[Chapter @sec-Long_and_Wide] で述べたように，昨今は計算機にとって優しい型，ロング型での入力もおおく，ANOVA君もversion 4.4.0からロング型での入力も許すようになった。その場合はオプション`long=TRUE` とロング型であることを明記する必要がある。

ANOVA君を使う時は，関数`anovakun`に，データ，要因計画の型，各要因の水準の順で入力する。ここで要因計画の型とは，文字列でBetween/Withinの違いを明示することになる。被験者のラベルを表す小文字の`s`を挟んで，左側に間(Between)要因，右側に内(Within)要因を入れる。例えば一要因Between計画の場合は`"As"`，二要因Within計画の場合は`"sAB"`，間1内2の混合計画であれば`"AsBC"`のようにする。

続いて入力する水準数は，要因の数だけ必要である。ただし，ロング型で入力した場合は自動的に水準数が計算されるので入力の必要がない。

このテキストでは，データの持ち替えについてすでに触れているので，色々扱いやすいロング型に整形して利用していくものとする。

## Betweenデザイン

### 1way-ANOVA

もっとも単純な一要因3水準，Between計画の例から始めよう。仮想データの生成を行うことで，分散分析のメカニズムと共に見ていくことにする。

```{r}
set.seed(123)
# 各群のサンプルサイズ
n1 <- 5
n2 <- 4
n3 <- 6
# 母平均，効果量，母SD
mu <- 10
delta <- 1
sigma <- 3
# 群平均
mu1 <- mu -(delta * sigma)
mu2 <- mu
mu3 <- mu + (delta * sigma)
# データセット
X1 <- rnorm(n1, mu1, sigma)
X2 <- rnorm(n2, mu2, sigma)
X3 <- rnorm(n3, mu3, sigma)
## 組み上げる
dat <- data.frame(
    ID = 1:(n1+n2+n3),
    group = as.factor(rep(LETTERS[1:3],c(n1,n2,n3))),
    value = c(X1,X2,X3)
)
## データの確認
dat
### 実行
anovakun(dat, "As", long = TRUE, peta = TRUE)
```

出力結果は大きく分けて記述統計`<< DESCRIPTIVE STATISTICS >>`と，分散分析表`<< ANOVA TABLE >>`，下位検定`<< POST ANALYSES >>`に分けられる。記述統計はデータが正しく読み込めているかどうかのチェックに使おう。

一番のメインは分散分析表であり，平方和sum of squaresを自由度dfで割った，1自由度あたりのデータの散らばりを，群間と群内(誤差)との比で検証しているのが見て取れる。群間平方和が$98.38$，群内平方和が$89.58$であり，それぞれ自由度$2$($3$水準$-1$)と$12$($\sum_{j=1}^3 n_j-1$)から生じているので，平均平方Mean Squaresがそれぞれ$49.19$と$7.47$である。この比が$6.5897$で，自由度$F(2,12)$のF分布においてこの値以上の極端な数字が出る確率が5%を下回っている(実に$p=0.0117$である)ため，統計的に有意であると判断できる。
分散分析表のTotalのところで，全体のSSが群間SS+群内SSに一致していること，自由度も全体df=群間df+群内dfになっていることを確認しておこう。

また，`anovakun`関数の引数として`peta = TRUE`を指定したが，これは偏$\eta^2$(partial eta)と呼ばれる効果量を出力するためのオプションである。

今回は分散分析の時点で統計的な有意差が認められたため($F(2,12)=6.59, p < 0.05, \eta^2=0.52$)，続いて下位検定が表示されている。ANOVA君は下位検定についても複数のオプションを持っているが，デフォルトではShafferの修正Bonferroni検定が行われる。詳しくは専門書[@Nagata20050401]を参照してほしいが，概略を説明すると，検証すべき仮説の数で有意水準を分割するというBonferroniの方法を，競合する仮説の数も考慮して分母を調整するというものである。

この計算の結果，A群とC群の間にのみ統計的な有意差が確認された($t(12)=3.61,p<0.05$)と言える。

### 2way-ANOVA

二要因の場合も見ておこう。ANOVA君の表記方法は要因計画の型が変わるだけで大きな変更はないが，交互作用interactionを考える必要があるところがポイントである。これも仮想データの組成を見ることでその意義がわかりやすくなるだろう。間2$\times$間2の実験デザインを例に，まずは各水準の理論的平均値がどのようにつくられるかをみておこう。

```{r}
set.seed(123)
# 各群のサンプルサイズ
n <- 10
# 全体平均，効果量，母SD
mu <- 10
delta1 <- 1
delta2 <- 0 # ここではあえて要因Bの効果を0にしている
delta3 <- 2
sigma <- 3
# 効果の計算
effectA <- delta1 * sigma   # Factor A
effectB <- delta2 * sigma   # Factor B
effectAB <- delta3 * sigma  # interaction
# 各群の平均
mu11 <- mu + effectA + effectB + effectAB
mu12 <- mu + effectA - effectB - effectAB
mu21 <- mu - effectA + effectB - effectAB
mu22 <- mu - effectA - effectB + effectAB
```

効果の現れ方は相対的だから，要因Aが第一水準に`+effectA`の形で現れたら，第二水準には`-effectA` の形で現れる。要因Bについても同様である。交互作用については組み合わせにおいて生じるから，要因Aの第一水準と要因Bの第一水準の組み合わせのところに`+effectAB`を充てる。ここでも効果は相対的に現れるという条件を守るために，要因Aの第一水準の中で`+effectAB`の効果を相殺するために，要因Aの第一水準と要因Bの第二水準の組み合わせの符号が反転する。同様に，要因Bの第一水準の中で相殺するために要因Aの第二水準と要因Bの第一水準には`-effectAB`が加わる。

このようにして考えられる理論的平均値に対して，外乱要因である誤差が生じて実現値が得られる。
組み上げて得られたデータを確認しておこう。
```{r}
X11 <- rnorm(n, mean = mu11, sd = sigma)
X12 <- rnorm(n, mean = mu12, sd = sigma)
X21 <- rnorm(n, mean = mu21, sd = sigma)
X22 <- rnorm(n, mean = mu22, sd = sigma)
dat <- data.frame(ID = 1:(n*4),
                    FactorA = rep(1:2,each = n*2),
                    FactorB = rep(rep(1:2,each = n),2),
                    value = c(X11,X12,X21,X22))
dat
```

もちろん実際には，計画に応じたデータセットが得られているはずであり，各群のサンプルサイズが異なるなどの事情もあるだろう。しかしこうして，理論的にデータの組成を見ておくことで，サンプルサイズを変えたり効果量を変えたりしながら，どのように結果が変わってくるかを確認しながら進めることができる[^9.2]。

[^9.2]: かつては分散分析は手計算でできる分析モデルであり，得られたデータを平方和に分解していくプロセスをたどりながら分散分析のメカニズムが体得されるという教育が多く見られた。ただしその方法は計算に時間がかかること，ミスが混在しやすいことに加え，手元のデータが唯一無二のものであるという印象を強くすることが懸念される。推測統計学においては，手元のデータはあくまでも実現値に過ぎないと考えるのであり，乱数を生成して幾つでも自在に作り出せる経験を得た方が教育効果として良いのではないか，と筆者は考えている。

それではこの仮想データを分析してみよう。
```{r}
anovakun(dat, "ABs", long = TRUE, peta = TRUE)
```

基本的な結果の見方については，一要因のときと同じである。今回は要因Aと交互作用の効果を作り，正しく検出されている。下位検定については，要因Aが2水準であったためこちらの主効果の検証は必要なく(記述統計を見て群平均比較をすればよい)，交互作用についての単純効果の検証が行われている。

## Withinデザイン

