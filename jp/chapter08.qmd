# 平均値差の検定

平均値差の検定は，実験計画の結論を出すために用いられる手段である。無作為割り当てによって個人差や背景要因が相殺され，平均的な因果効果を検証することができるからである。
その結果を一般化するためには，やはり推測統計学の知見が必要であり，サンプルサイズやタイプ1,2エラーが関わってくることに変わりはない。

## 一標本検定

まず配置標本検定の例から始める。母平均がわかっている，あるいは理論的に仮定される特定の値に対して，標本平均が統計的に有意に異なっていると言って良いかどうかの判断をするときに用いる。
たとえば7件法のデータを取ったときに，ある項目の平均が中点4より有意に離れていると言って良いかどうか，といった判定をするときに用いる。かりに，サンプルサイズ10で7件法のデータが得られたとしよう。ここでは平均4,SD1の正規乱数を10件生成することで表現する。実際にはこの値を，人に対する尺度カテゴリへの反応として得ているはずである。

```{r,oneTsample}
library(tidyverse)
set.seed(17)
n <- 10
mu <- 4
X <- rnorm(n, mean = mu, sd = 1)
print(X)
```

今回，標本平均は`r round(mean(X),3)`であり，これより極端な値が$\mu = 4$の母集団から得られるかどうかを検定する。帰無仮説検定の手順にそって進めていくと，以下のようになる。

1. 帰無仮説は母平均が理論的な値(ここでは尺度の中点4)であること，すなわち$\mu =4$であり，対立仮説は$\mu \neq 4$ である。
2. 検定統計量は，正規母集団から得られる標本平均が従う標本分布であり，母分散が未知の場合の区間推定に用いたT統計量になる。
3. 判断基準は心理学の慣例に沿って5%とする。

このあと，検定統計量の計算と判定である。これをRは`t.test`関数で一気に処理できる。

```{r,Os.ttest}
result <- t.test(X, mu = mu)
print(result)
```

結果として，今回の検定統計量の実現値は`r round(result$statistic,3)`であり，自由度`r result$parameter`のt分布からこれ以上の値が出てくる確率は，`r round(result$p.value,3)`であることがわかる。これは5%水準と見比べてより大きいので，レアケースではないと判断できる。つまり，母平均4の正規母集団から，`r round(mean(X),3)`の標本平均が得られることはそれほど珍しいものではなく，統計的に有意に異なっていると判断するには及ばない，ということである。

レポートなどに記載するときは，これら実現値やp値を踏まえて「$t(9)=0.66776,p=0.5151 ,n.s.$」などとする。ここでn.s.はnot significantの略である。

さてこの例では，母平均4の正規乱数を生成し，その平均が4と異なるとはいえない，と結論づけた。これは一見，当たり前のことのようであり，無意味な行為におもえるかもしれない。しかし次の例を見てみよう。

```{r,Os.ttest2}
n <- 3
mu <- 4
X <- rnorm(n, mean = mu, sd = 1)
mean(X) %>%
  round(3) %>%
  print()
result <- t.test(X, mu = mu)
print(result)
```

ここではサンプルサイズ$n=3$であり，標本平均が`r round(mean(X),3)`であった。このときt値は5%臨界値を上回っており，「母平均4のところから得られる値にしては極端」であるから，統計的に有意に異なる，と判断することになる。乱数生成時は平均を確かに4に設定したが，母平均から取り出したごく一部が，そこから大きく離れてしまうことはあり得るのである。

## 二標本検定

続いて二標本の検定について考えよう。実験群と統制群のように，無作為割り当てをすることで平均因果効果をみる際に行われるのが，この検定である。帰無仮説は「群間差はない」であり，対立仮説はその否定である。また，正規母集団からの標本を仮定するので，検定統計量はここでもt分布に従う値になる。帰無仮説検定の手順に沿って，改めて確認しておこう。

1. 帰無仮説は「二群の母平均に差がない」である。二群の母平均をそれぞれ$\mu_1,\mu_2$とすると，帰無仮説は$\mu_1 = \mu_2$，あるいは$\mu_1 - \mu_2 = 0$と表される。対立仮説は$\mu_1 \neq \mu_2$あるいは$\mu_1-\mu_2 \neq 0$である。
2. 検定統計量は，正規母集団から得られる標本平均が従う標本分布であり，母分散が未知の場合の区間推定に用いたT統計量になる。
3. 判断基準は心理学の慣例に沿って5%とする。

これを検証するために，サンプルデータを乱数で生成しよう。
まず，各群のサンプルサイズを`n1,n2`とする。ここでは話を簡単にするため，サンプルサイズは両群ともに`10`とした。つぎに両群の母平均だが，群1の母平均を$\mu_1$，群2の母平均を$\mu_2 = \mu_1 + \delta$で表現した。この$\delta$は差分であり，これが$\delta=0$であれば母平均が等しいこと，$\delta \neq 0$であれば母平均が異なることになる。最後に両群の母SDを設定した。

ここでの検定は，この差分$d$が母平均0の母集団から得られたと判断して良いかどうか，という形で行われる。検定統計量$T$は，次式で算出されるものである。

$$ T = \frac{d - \mu_0}{\sqrt{U^2_p/\frac{n_1n_2}{n_1+n_2}}}$$

ここで$d$は二群の標本平均の差であり，$U^2_p$はプールされた不偏分散と呼ばれ，二群を合わせて計算された全体の母分散推定量である。各群の標本分散をそれぞれ$S^2_1, S^2_2$とすると，次式で算出される。

$$ U^2_p = \frac{n_1S^2_1+ n_2S^2_2}{n_1 + n_2 -2} $$

これらの式はつまり，サンプルサイズの違いを考慮するため，一旦両群の標本分散に各サンプルサイズを掛け合わせ，プールした全体のサンプルサイズから各々$-1$をすることで全体として不偏分散にしている。

これを踏まえて，具体的な数字で見ていこう。
その上で乱数でデータを生成し，その標本平均を確認した上で，`t.test`関数によって検定を行っている。

```{r,Ts.ttest}
n1 <- 10
n2 <- 10
mu1 <- 4
sigma <- 1
delta <- 1
mu2 <- mu1 + (sigma * delta)

set.seed(42)
X1 <- rnorm(n1, mean = mu1, sd = sigma)
X2 <- rnorm(n2, mean = mu2, sd = sigma)

X1 %>%
  mean() %>%
  round(3) %>%
  print()
X2 %>%
  mean() %>%
  round(3) %>%
  print()

result <- t.test(X1, X2, var.equal = TRUE)
print(result)
```

今回の母平均は$\mu_1 = 4, \mu_2 = 4+1$にしているが，標本平均は`r round(mean(X1),3)`と`r round(mean(X2),3)`であり，標本上では大きな差が見られなかった。結果として，t値は`r abs(result$statistic)`であり，自由度`r result$parameter`のもとでのp値は`r result$p.value`である。5%水準を上回る値であるから，結論としては対立仮説を採択するには至らない，差があるとはいえない，である。

今回の設定では母平均に差があるはず($4 \neq 4 + 1$)なのだから，これは誤った判断で，タイプ2エラーが生じているケースということになる。研究実践場面では，母平均やその差については知り得ないのだから，このような判断ミスが生じていたかどうかは分かり得ないことに留意しよう。

なお，ここではわかりやすく2群であることを示すために`X1`,`X2`と2つのオブジェクトを用意したが，実践的にはデータフレームの中で群わけを示す変数があり，`formula`の形で次のように書くことが多いだろう。

```{r}
dataSet <- data.frame(group = c(rep(1, n1), rep(2, n2)), value = c(X1, X2)) %>%
  mutate(group = as.factor(group))
t.test(value ~ group, data = dataSet, var.equal = TRUE)
```


## 二標本検定(ウェルチの補正)

先ほどのt.test関数には，`var.equal = TRUE`というオプションが追加されていた。これは2群の分散が等しいと仮定した場合の検定になる。t検定は歴史的にこちらが先に登場しているが，2群の分散が等しいかどうかはいきなり前提できるものでもない。等分散性の検定は，Levene検定を行うのが一般的であり，R においては，`car`パッケージや`lawstat` パッケージが対応する関数を持っている。ここでは`car`パッケージの `leveneTest`関数を用いる例を示す。

```{r}
#| message: FALSE
library(car)
leveneTest(value ~ group, data = dataSet, center = mean)
```

この結果を見ると，p値から明らかなように，2群の分散が等しいという帰無仮説が棄却**できなかった**ので，等しいと考えてt検定に進むことができる。もしこれが棄却されてしまったら，2群の分散が等しいという帰無仮説が成り立たないのだから，等分散性の仮定を外す必要がある。実行は簡単で，`var.equal`を`FALSE`にすれば良い。

```{r}
result2 <- t.test(value ~ group, data = dataSet, var.equal = FALSE)
print(result2)
```
よく見ると，タイトルがWelch Two Sample t-testに変わっている。Welchの補正が入ったt検定という意味である。また自由度が実数(`r round(result2$parameter,3)`)になっているが，このようにt分布の自由度を調整することで等分散性の仮定から逸脱した場合の補正となる。もちろん報告する際は「$t($ `r round(result2$parameter,3)` $)=$ `r round(result2$statistic,3)`, $p=$ `r round(result2$p.value,3) `」のように書くことになるから，自由度が実数であれば補正済みであると考えられるだろう。

しかし，分散が等しいという仮定は，等しくない場合の特殊な場合であるから，最初からWelchの補正がはいった検定だけで十分である。このような考え方から，Rにおける`t.test` 関数のデフォルトでは`var.equal = FALSE`となっており，特段の指定をしなければ等分散性の仮定をしない。こちらの方が検定を重ねることがないので，より望ましい。

### 効果量の算出

今回の例は，仮想データとして$\mu_1 = 4,\mu_2 = \mu_1 + \sigma d$であり，明らかに$\mu_1 \neq \mu_2$なのだが，有意差を検出するには至らなかった。統計的な有意差はあくまでも「統計的な」観点からのものであり，我々が現実に検証したいのは本当に差があるかどうか，いわば「実質的な差」があるかどうかであるのだから，統計的な有意差を得ることを目的にするのははっきりと不適切な目標設定であると言えるだろう[^8.1]。

[^8.1]: たとえば物理学などのシーンでは，測定の精度が高く，単一の物理世界を対象にした検証を行うのだから，予測が真であるか偽であるかを確率的に考えるような必要はない。そのような世界における検証--あえて理論的な正しさが明確な世界，と表現するが--であれば，統計的な差があるかどうかの情報はあくまでも理論を支持するおまけ情報にすぎない。いわば統計的検定の結果を報告するのは，論文を書くためのレトリックである。翻って，人間を対象にした小サンプルの科学である心理学は，統計的な判断に頼らざるを得ないという側面はあるだろう。しかしだからと言って，実質的な差が本質的であることを忘れてしまっては本末転倒である。

ところで，統計的に差があるとはっきり言えるのはどのような時だろうか。これは次の4つのデータの分布を見てもらうとわかりやすい。


```{r}
#| echo: FALSE
#| message: FALSE
library(tidyverse)
library(ggplot2)
library(gridExtra)
dL <- 2
dS <- 0.2
sL <- 2
sS <- 0.2

g1 <- ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
  stat_function(fun = dnorm, args = list(mean = dL, sd = sS), color = "red") +
  stat_function(fun = dnorm, args = list(mean = -dL, sd = sS), color = "blue") +
  xlab("") +
  ylab("") +
  theme(axis.text.y = element_blank())
g2 <- ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
  stat_function(fun = dnorm, args = list(mean = dS, sd = sS), color = "red") +
  stat_function(fun = dnorm, args = list(mean = -dS, sd = sS), color = "blue") +
  xlab("") +
  ylab("") +
  theme(axis.text.y = element_blank())
g3 <- ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
  stat_function(fun = dnorm, args = list(mean = dL, sd = sL), color = "red") +
  stat_function(fun = dnorm, args = list(mean = -dL, sd = sL), color = "blue") +
  xlab("") +
  ylab("") +
  theme(axis.text.y = element_blank())
g4 <- ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
  stat_function(fun = dnorm, args = list(mean = dS, sd = sL), color = "red") +
  stat_function(fun = dnorm, args = list(mean = -dS, sd = sL), color = "blue") +
  xlab("") +
  ylab("") +
  theme(axis.text.y = element_blank())
g <- grid.arrange(g1, g2, g3, g4)
```

左列は平均差が大きいデータ，右列は小さいデータである。
上段は分散が小さいデータ，下段は大きいデータである。
この4つそれぞれのシーンにおいて，「差がある」と判断しやすいのはどれかを考えてみるとよい。当然，左上のシーンが最も明確に差があると言えるであろう。なぜなら，両群が明確に分かれており，群間の重複がないからである。左下は同じ平均値差であっても，群内の広がりが大きいから群間の重複がみられるため，「差がある」という判断を受けても各群の中には該当しないケースがちらほらみられることだろう。右上パネルのようなケースでは，重複は少ないが差が小さいため，「差がある」と判断できるかどうかが微妙である。右下に至っては，差も小さく分布の重複も大きいから，「差がある」と判断しても該当しないケースが多くなる。たとえば「男性は女性よりも力が強い(体力・筋力に差がある)」というデータがあったとしても，「女性より非力な男性」もかなり多く存在するだろう。そういう反例が多くみられるような場合，統計的に差があるという結果が示されたとしても，受け入れられないのではないだろうか。

ここから明らかなように，差の判断には平均値差だけでなく分散も関わってくる。そこで平均値差を標準偏差で割った，**標準化された差**が重要になってくるのであり，これが**効果量**と呼ばれるものである[^8.2]。

[^8.2]: 統計的な有意差よりも効果量，効果量よりも実質的な差のほうが意味のある差であることを忘れてはならない。詳しくは @Toyoda2009 を参照。

今回2群の差のデータを作る時に，$\sigma d$ としたが，平均値差の効果量esは，
$$ es = \frac{\mu_1 - \mu_2}{\sigma} $$

で表現されるから，$d$が効果量を表していたのである。もちろん我々は母平均，母SDなどを知り得ないのでこれもデータから推定する他ない。幸いRには`effsize`パッケージなど，効果量を算出するものが用意されている。

```{r}
library(effsize)
cohen.d(value ~ group, data = dataSet)
cohen.d(value ~ group, data = dataSet, hedges.correction = TRUE)
```

平均値差の検定の後は，ここに示したCohenのdやHedgesのgといった効果量を添えて報告することが一般的である。

## 対応のある二標本検定

実験群と統制群のように異なる2群ではなく，プレポスト実験のように対応がある2群の場合は，t検定の定式化が異なる。対応がないt検定の場合は，群平均の差$\mu_1 - \mu_2$の分布を考えたが，対応がある場合は個々の測定の差，つまり$X_{i1} - X_{i2} = D_i$を考える。この一つの標本統計量を検定するのだから，一標本検定の一種であるとも言える。またこのDの分布の標準誤差は，標本標準誤差$U_D$を使った$U_D/\sqrt{n}$を使って推定する[^8.3]。検定統計量$T$は，次式で算出される。

$$ T = \frac{\bar{D}}{U_D/\sqrt{n}} = \frac{\sum D_i/n}{\sqrt{\frac{\frac{1}{n-1}\sum(D_i-\bar{D})^2}{n}}}$$

[^8.3]: 対応があるケースを考えているので，当然$n$は前後の群で同数である。

検定にあたっては，`t.test`関数の引数`paired`を`TRUE`にするだけで良い。

### 仮想データの組成

仮想データを作って演習してみよう。データの組成については，2種類のアプローチで説明が可能である。ひとつは次のシミュレーションで表されるような形である。
```{r}
n <- 10
mu1 <- 4
sigma <- 1
d <- 1
X1 <- rnorm(n, mu1, sigma)
X2 <- X1 + sigma * d + rnorm(n, 0, sigma)
t.test(X1, X2, paired = TRUE)
```

すなわち，第一の群が$\mu_1$を平均にばらついた実現値として得られ，第二の群はその実現値に一定の効果$\sigma *d$が加わり，その測定にさらに誤差がつく形である。この方法は具体的なデータ生成プロセスをそのまま模したような形でデータを作っているが，測定誤差を二重に計上している点が気になるかもしれない。

もう一つの考え方は，プレポスト型のデータに限らず，何らかの形で「対応がある」ことも表現できるものである。対応があるということは，2つのデータがそれぞれ独立した一変数正規分布から得られているのではなく，二変数正規分布から得られると考えるのである。二変数正規分布は，それぞれの変数は正規分布しているが，両者の間に相関があると考えるものである。変数が一つだけの正規分布は
$$X \sim N(\mu,\sigma)$$
で表現されているのに対し，複数の変数を同時に生成する多変数(多次元)正規分布Multivariate Normal Distributionは，以下のように表現される。
$$ \mathbf{X} \sim MVN(\mathbf{\mu},\mathbf{\Sigma})$$

ここで$\mathbf{X}$や$\mathbf{\mu}$は$n$次元ベクトルであり，$\mathbf{\Sigma}$は分散共分散行列を表している。二変数の場合は以下のように書くことができる。

$$\mathbf{\Sigma} = \begin{pmatrix} \sigma_1^2 & \sigma_{12}\\ \sigma_{21} & \sigma_2^2 \end{pmatrix} = \begin{pmatrix} \sigma_1^2 & \rho_{12}\sigma_1\sigma_2 \\ \rho_{21}\sigma_2\sigma_1 & \sigma_2^2 \end{pmatrix}$$

共分散$\sigma_{ij}$は相関係数$\rho_{ij}$を用いて書けることからわかるように，変数間に相関があることを想定してデータを生成するのである。この組成に従った仮想データの作成は以下のとおりである。

```{r}
#| message: FALSE
library(MASS) # 多次正規乱数を生成するのに必要
n <- 10
mu1 <- 4
sigma <- 1
d <- 1
mu <- c(mu1, mu1 + sigma * d)
rho <- 0.4
SIG <- matrix(c(sigma^2, rho * sigma * sigma, rho * sigma * sigma, sigma^2), ncol = 2, nrow = 2)
X <- mvrnorm(n, mu, SIG)
t.test(X[, 1], X[, 2], paired = TRUE)
```

効果量については，対応のないt検定の場合と同じで良い。

```{r}
cohen.d(X[, 1], X[, 2])
cohen.d(X[, 1], X[, 2], hedges.correction = TRUE)
```

### 検定の方向性

ここまでの検定では，主に「差があるかどうか」といった仮説に対応するものを扱ってきた。差があるかどうか，というのはその差がプラスの方向にでているのか，マイナスの方向に出ているのかといったことを問題にしていない。そこで検定統計量の分布についても，分布の両裾を考えて有意水準を設定していた。

しかしプレポスト実験などでは，効果が「上がった」のか「下がった」のか，ということが大きな関心時でもあることが多いだろう。効果がある，ただし逆効果である，というのでは意味がないからである。このように方向性をもった仮説を検証する場合は，検定統計量の分布も一方向だけ考えればよく，`t.test`関数には`alternative`オプションをつかって表現する。

`t.test(x,y,alternatives = "less")` とすると$x < y$の帰無仮説を検証することになるし，`alternatives = "greater"`とすると$x > y$の帰無仮説を検証することになる。デフォルトでは`alternatives = "two.sided"`であり，両側検定が選ばれている。

ただし，両裾から片裾にかわるということは，検定統計量が超えるかどうかの判断をする**臨界値**が小さくなることでもある。必然的に，片裾(片側検定)のほうが緩やかな基準で検定をしていることにもなる。デフォルトで普段から厳しく検定しているから大丈夫だろう，というのも一つの考え方だが，やはり本来の研究仮説に適した帰無仮説の設定をするべきだろう。

## 課題

1. 平均が50、標準偏差が10の正規分布からランダムに選んだ30個のサンプルを用意し，このサンプルの平均が母集団の平均と異なるかどうかを検定してください。検定結果を，心理学のフォーマット(心理学会編「論文執筆投稿の手引き」)に準拠した書き方で，結果を記述してください。
2. 以下のデータセットを使用して，2つの独立した群の平均に差があるかどうかをt検定してください。検定結果を，心理学のフォーマット(心理学会編「論文執筆投稿の手引き」)に準拠した書き方で，結果を記述してください。
$$ group1 =\{45, 50, 55, 60, 65 \} $$
$$ group2 = \{57, 60, 62, 77, 75 \} $$

3. 多次元正規分布を用いた仮想データ生成方で，対応のあるt検定の練習をしましょう。サンプルサイズを$n=20$とし, 平均ベクトル$\mu = (12, 15)$, 分散共分散行列$\Sigma = \begin{pmatrix} 4 & 2.8 \\ 2.8 & 4\end{pmatrix}$の多次元正規分布から作られた乱数を使って，対応のあるt検定をしてください。検定結果を，心理学のフォーマット(心理学会編「論文執筆投稿の手引き」)に準拠した書き方で，結果を記述してください。

4.  自由度が10, 20, 30のt分布のグラフを，標準正規分布のグラフとともに描画してください。自由度が増えるとt分布がどのように変化するでしょうか。
5. 自由度が15のt分布において、有意水準5%の片側検定と両側検定の臨界値(検定の判断基準となる理論値)を求めてください。

```{r}
#| echo: FALSE
#| eval: FALSE
#| include: FALSE

library(tidyverse)

# 課題1
set.seed(123)
sample_data <- rnorm(30, mean = 50, sd = 10)

# t検定の実行
t_test_result <- t.test(sample_data, mu = 50)

# 検定結果の表示
t_test_result

# 結果の記述
# t(29) = t値, p = p値
cat("t(", t_test_result$parameter, ") = ", t_test_result$statistic, ", p = ", t_test_result$p.value, sep = "")

# 平均が50、標準偏差が10の正規分布からランダムに選んだ30個のサンプルの平均が母集団の平均50と
# 異なるかを検定した結果、有意な差は見られなかった（t(29) = -0.195, p = 0.847）。

# 課題2
group1 <- c(45, 50, 55, 60, 65)
group2 <- c(57, 60, 62, 77, 75)

# t検定の実行
t_test_result <- t.test(group1, group2, var.equal = TRUE)

# 検定結果の表示
t_test_result

# 結果の記述
# t(df) = t値, p = p値
cat("t(", t_test_result$parameter, ") = ", t_test_result$statistic, ", p = ", t_test_result$p.value, sep = "")

# 2つの独立した群の平均に差があるかを検定した結果、有意な差が見られた（t(8) = -2.838, p = 0.022）。

# 課題3
library(MASS)

# 多次元正規分布からデータ生成
set.seed(123)
n <- 20
mu <- c(12, 15)
Sigma <- matrix(c(4, 2.8, 2.8, 4), ncol = 2)
data <- mvrnorm(n, mu = mu, Sigma = Sigma)

# 対応のあるt検定の実行
t_test_result <- t.test(data[, 1], data[, 2], paired = TRUE)

# 検定結果の表示
t_test_result

# 結果の記述
# t(df) = t値, p = p値
cat("t(", t_test_result$parameter, ") = ", t_test_result$statistic, ", p = ", t_test_result$p.value, sep = "")

# 対応のあるt検定を行った結果、有意な差が見られた（t(19) = -9.256, p < 0.001）。

# 課題4
# データの作成
x <- seq(-4, 4, length = 1000)
df_values <- c(10, 20, 30)
norm_density <- dnorm(x)

# データフレームの作成
df <- data.frame(x = x, norm = norm_density)
for (df_val in df_values) {
  df[paste("t_df", df_val, sep = "_")] <- dt(x, df = df_val)
}

# データの整形
df_long <- gather(df, key = "distribution", value = "density", -x)

# グラフの描画
ggplot(df_long, aes(x = x, y = density, color = distribution)) +
  geom_line(size = 1) +
  labs(
    title = "t-Distributions with Different Degrees of Freedom and Normal Distribution",
    x = "x", y = "Density"
  ) +
  scale_color_manual(
    values = c("black", "blue", "green", "red"),
    labels = c("Normal", "t (df = 10)", "t (df = 20)", "t (df = 30)")
  ) +
  theme_classic()

# 課題5
# 片側検定の臨界値
critical_value_one_sided <- qt(0.95, df = 15)

# 両側検定の臨界値
critical_value_two_sided <- qt(0.975, df = 15)

# 結果の表示
cat("片側検定の臨界値: ", critical_value_one_sided, "\n")
cat("両側検定の臨界値: ", critical_value_two_sided, "\n")
```
